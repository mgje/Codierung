// Generated by CoffeeScript 2.1.0
(function() {
  // LZW-compress a string
  var addcolumn, addinnerEvents, bfromcode, bt, bt2, bt3, bt4, btf, clearAllChilds, createCodeBlock, createCodeRows, createCodeTable, createRandomMatrix, createRowCodeTable, dec, dec_lzw, decodeBIT, decodeL, decodeLZW, defineStyle, deselectFarb, el, elformat, enc, enc_lzw, encodeBIT, encodeL, encodeLZW, evaluateInput, grid, handlerColorChage, makeclone, mincolumn, outCode, outParamet, selectFarb, updateCell, updateMatrix, wout;

  enc_lzw = function(s) {
    var bits, c, code, currChar, data, elformat, i, l, len, m, o, out, outchar, p, phrase, ref, ref1, ref2;
    this.dict = {};
    data = (s + "").split("");
    out = [];
    outchar = [];
    phrase = data[0];
    code = 8;
    for (i = l = 1, ref = data.length; 1 <= ref ? l < ref : l > ref; i = 1 <= ref ? ++l : --l) {
      currChar = data[i];
      if (this.dict[phrase + currChar] !== void 0) {
        phrase += currChar;
      } else {
        if (phrase.length > 1) {
          out.push(this.dict[phrase]);
        } else {
          out.push;
        }
        this.farbNr[phrase];
        this.dict[phrase + currChar] = code;
        code++;
        phrase = currChar;
      }
    }
    // Anzahl Code Elemente
    this.anzCode = code;
    if (phrase.length > 1) {
      out.push(this.dict[phrase]);
    } else {
      out.push(this.farbNr[phrase]);
    }
    
    // calc Code Length
    bits = 8;
    for (m = 0, len = out.length; m < len; m++) {
      c = out[m];
      if (c < 256) {
        bits += 8;
      } else if (bits < 65536) {
        bits += 16;
      } else {
        bits += 24;
      }
    }
    this.bits = bits;
    this.outputParameters();
    elformat = document.getElementById("selectCodeFormat");
    if (elformat.value === "Zeichen") {
      for (i = o = 0, ref1 = out.length; 0 <= ref1 ? o < ref1 : o > ref1; i = 0 <= ref1 ? ++o : --o) {
        outchar[i] = String.fromCharCode(out[i] + 97);
      }
      return outchar.join("");
    } else if (elformat.value === "Zahlen Code") {
      return out.join(",");
    } else {
      for (i = p = 0, ref2 = out.length; 0 <= ref2 ? p < ref2 : p > ref2; i = 0 <= ref2 ? ++p : --p) {
        outchar[i] = out[i].toString(2);
      }
      return outchar.join(",");
    }
  };

  
  // Decompress an LZW-encoded string
  dec_lzw = function(s) {
    var bits, c, code, currChar, currCode, data, dict, i, l, len, m, oldPhrase, out, phrase, ref;
    dict = {};
    data = (s + "").split(",");
    currChar = this.farbCode[parseInt(data[0])];
    oldPhrase = currChar;
    out = [currChar];
    code = 8;
    for (i = l = 1, ref = data.length; 1 <= ref ? l < ref : l > ref; i = 1 <= ref ? ++l : --l) {
      currCode = data[i];
      if (currCode < 8) {
        phrase = this.farbCode[parseInt(currCode)];
      } else {
        if (dict[currCode]) {
          phrase = dict[currCode];
        } else {
          phrase = oldPhrase + currChar;
        }
      }
      out.push(phrase);
      currChar = phrase.charAt(0);
      dict[code] = oldPhrase + currChar;
      code++;
      oldPhrase = phrase;
    }
    
    // calc Code Length
    bits = 8;
    for (m = 0, len = data.length; m < len; m++) {
      s = data[m];
      c = parseInt(s);
      if (c < 256) {
        bits += 8;
      } else if (bits < 65536) {
        bits += 16;
      } else {
        bits += 24;
      }
    }
    this.bits = bits;
    this.outputParameters();
    return out.join("");
  };

  //DOM Help Functions
  wout = function(eid, output) {
    var e, t;
    e = clearAllChilds(eid);
    t = document.createTextNode(output);
    e.appendChild(t);
    return false;
  };

  clearAllChilds = function(id) {
    var e;
    e = document.getElementById(id);
    while (e.hasChildNodes()) {
      e.removeChild(e.lastChild);
    }
    return e;
  };

  // Create Grid
  createCodeBlock = function(k, n) {
    var i, l, ref, results;
    results = [];
    for (i = l = 0, ref = n; 0 <= ref ? l <= ref : l >= ref; i = 0 <= ref ? ++l : --l) {
      results.push(`<div id="${k * grid.col + i}" class="smallBox cell">\n	<div class="innerBox null"></div>\n</div>`);
    }
    return results;
  };

  createCodeRows = function() {
    var j, l, ref, results;
    results = [];
    for (j = l = 0, ref = this.row - 1; 0 <= ref ? l <= ref : l >= ref; j = 0 <= ref ? ++l : --l) {
      results.push(`<div class="zeile">\n${createCodeBlock(j, this.col - 1).join("")} \n</div>`);
    }
    return results;
  };

  addinnerEvents = function() {
    var e, id, l, ref, results, x, y;
    results = [];
    for (y = l = 0, ref = this.row; 0 <= ref ? l < ref : l > ref; y = 0 <= ref ? ++l : --l) {
      results.push((function() {
        var m, ref1, results1;
        results1 = [];
        for (x = m = 0, ref1 = this.col; 0 <= ref1 ? m < ref1 : m > ref1; x = 0 <= ref1 ? ++m : --m) {
          id = y * this.col + x;
          e = document.getElementById(id);
          e.addEventListener("mousedown", handleronChange, false);
          results1.push(false);
        }
        return results1;
      }).call(this));
    }
    return results;
  };

  defineStyle = function() {
    this.element.style.width = `${this.col * this.size}px`;
    return this.element.style.height = `${this.row * this.size}px`;
  };

  updateCell = function(i, s) {
    var el, inp;
    el = document.getElementById(i);
    inp = el.getElementsByClassName("numberInput")[0];
    return inp.value = s;
  };

  createRandomMatrix = function() {
    var d, l, m, ref, ref1, x, y, z;
    for (y = l = 0, ref = this.row; 0 <= ref ? l < ref : l > ref; y = 0 <= ref ? ++l : --l) {
      for (x = m = 0, ref1 = this.col; 0 <= ref1 ? m < ref1 : m > ref1; x = 0 <= ref1 ? ++m : --m) {
        d = Math.random();
        z = Math.floor(this.anzFarb * d);
        this.matrix[y * this.col + x] = this.farbCode[z];
      }
    }
    wout("rowcol", `${this.col} x ${this.row} |         ${this.col} Spalten / ${this.row} Zeilen`);
    return false;
  };

  updateMatrix = function() {
    var e, id, l, ref, results, x, y;
    results = [];
    for (y = l = 0, ref = this.row; 0 <= ref ? l < ref : l > ref; y = 0 <= ref ? ++l : --l) {
      results.push((function() {
        var m, ref1, results1;
        results1 = [];
        for (x = m = 0, ref1 = this.col; 0 <= ref1 ? m < ref1 : m > ref1; x = 0 <= ref1 ? ++m : --m) {
          id = y * this.col + x;
          e = (document.getElementById(id)).getElementsByTagName("div");
          results1.push(e[0].className = `innerBox ${this.farbTab[this.matrix[id]]}`);
        }
        return results1;
      }).call(this));
    }
    return results;
  };

  //Code Table
  createRowCodeTable = function() {
    var k, key, keys, l, len, results;
    keys = [];
    for (k in grid.dict) {
      keys.push(k);
    }
    keys.sort();
    results = [];
    for (l = 0, len = keys.length; l < len; l++) {
      key = keys[l];
      results.push(`<tr>\n  <td>${key}</td>\n  <td>${grid.dict[key]}</td>\n<tr>`);
    }
    return results;
  };

  createCodeTable = function() {
    return `<table class="table table-bordered table-striped">\n<thead>\n<th>\nLZW Tabelle\n</th>\n<th>\nAnzahl Codes: ${grid.anzCode}\n</th>\n</thead>\n<tbody class="">\n   <tr>\n	 <td><b>PIXEL FARBE</b></td>\n	 <td><b>WERT</b></td>\n	</tr>\n\n${createRowCodeTable().join("")}\n</tbody>\n</table>	`;
  };

  encodeLZW = function() {
    var el;
    this.code = this.col.toString() + ",";
    this.code += this.encode_lzw(this.matrix.join(""));
    clearAllChilds("LZW_Table");
    el = document.getElementById("LZW_Table");
    el.innerHTML = createCodeTable();
    return this.code;
  };

  encodeBIT = function() {
    var l, len, pixel, ref, s;
    // Bits berechnen
    this.bits = this.matrix.length * 3 + 8;
    this.outputParameters();
    this.code = this.col.toString();
    s = "";
    ref = this.matrix;
    for (l = 0, len = ref.length; l < len; l++) {
      pixel = ref[l];
      s += pixel;
    }
    return this.code += "," + s;
  };

  encodeL = function() {
    var farbe, l, len, pixel, ref, s, z;
    this.bits = 8;
    this.code = this.col.toString();
    s = "";
    farbe = this.matrix[0];
    z = 0;
    ref = this.matrix;
    for (l = 0, len = ref.length; l < len; l++) {
      pixel = ref[l];
      if (pixel === farbe) {
        z = z + 1;
      } else {
        s += z.toString() + farbe;
        if (z < 256) {
          this.bits += 11;
        } else {
          this.bits += 19;
        }
        z = 1;
        farbe = pixel;
      }
    }
    s += z.toString() + farbe;
    if (z < 256) {
      this.bits += 11;
    } else {
      this.bits += 19;
    }
    this.outputParameters();
    return this.code += "," + s;
  };

  // Encoding
  enc = function() {
    var el;
    el = document.getElementById("selectCode");
    if (el.value === "Bitmap Codierung") {
      return this.enBIT();
    } else if (el.value === "LZW Codierung") {
      return this.enLZW();
    } else {
      return this.enL();
    }
  };

  decodeLZW = function() {
    var c, col, elformat, l, len, len1, m, ref, tmp, tmpc, tmpc2, x;
    elformat = document.getElementById("selectCodeFormat");
    tmpc = this.code.split(",");
    if (elformat.value === "Zahlen Code") {
      col = parseInt(tmpc.shift());
      tmp = this.decode_lzw(tmpc.join(","));
    } else if (elformat.value === "Binär Code") {
      col = parseInt(tmpc.shift());
      tmpc2 = [];
      for (l = 0, len = tmpc.length; l < len; l++) {
        x = tmpc[l];
        tmpc2.push(parseInt(x, 2));
      }
      tmp = this.decode_lzw(tmpc2.join(","));
    } else {
      alert("not Implemented");
      col = 10000;
    }
    // col = parseInt tmpc[0]
    // tmp = @decode_lzw tmpc[1]
    if (col > this.maxcol) {
      alert(`Es können nicht ${col} Pixel pro Zeile dargestellt werden. Die maximale Anzahl Pixel beträgt ${this.maxcol} `);
    } else {
      this.col = col;
      this.matrix = [];
      ref = tmp.split("");
      // Code in der Form "PPPNNGS"
      for (m = 0, len1 = ref.length; m < len1; m++) {
        c = ref[m];
        if (c in this.farbTab) {
          this.matrix.push(c);
        }
      }
      this.row = Math.floor(this.matrix.length / this.col);
      // Angefangene Zeile
      if (this.row !== 1.0 * this.matrix.length / this.col) {
        this.row += 1;
      }
    }
    return false;
  };

  decodeBIT = function() {
    var c, col, l, len, ref, tmpc;
    tmpc = this.code.split(",");
    col = parseInt(tmpc[0]);
    if (col > this.maxcol) {
      alert(`Es können nicht ${col} Pixel pro Zeile dargestellt werden. Die maximale Anzahl Pixel beträgt ${this.maxcol} `);
    } else {
      this.col = col;
      this.matrix = [];
      ref = tmpc[1].split("");
      for (l = 0, len = ref.length; l < len; l++) {
        c = ref[l];
        if (c in this.farbTab) {
          this.matrix.push(c);
        }
      }
      this.bits = tmpc[1].length * 3 + 8;
      this.outputParameters();
      this.row = Math.floor(this.matrix.length / this.col);
      // Angefangene Zeile
      if (this.row !== this.matrix.length / this.col) {
        this.row += 1;
      }
    }
    return false;
  };

  decodeL = function() {
    var c, col, f, j, l, len, m, ref, sz, tmp2, tmpc, z;
    tmpc = this.code.split(",");
    col = parseInt(tmpc[0]);
    if (col > this.maxcol) {
      alert(`Es können nicht ${col} Pixel pro Zeile dargestellt werden. Die maximale Anzahl Pixel beträgt ${this.maxcol} `);
    } else {
      this.col = col;
      this.matrix = [];
      this.bits = 8;
      tmp2 = tmpc[1].match(/\d+\D/g);
      for (l = 0, len = tmp2.length; l < len; l++) {
        c = tmp2[l];
        sz = c.match(/\d+/);
        z = parseInt(sz);
        if (z < 256) {
          this.bits += 11;
        } else {
          this.bits += 19;
        }
        f = c.match(/\D/);
        if (f in this.farbTab) {
          for (j = m = 0, ref = z; 0 <= ref ? m < ref : m > ref; j = 0 <= ref ? ++m : --m) {
            this.matrix.push(f[0]);
          }
        }
      }
      this.outputParameters();
      this.row = Math.floor(this.matrix.length / this.col);
      // Angefangene Zeile
      if (this.row !== this.matrix.length / this.col) {
        this.row += 1;
      }
    }
    return false;
  };

  dec = function() {
    var el;
    el = document.getElementById("selectCode");
    if (el.value === "Bitmap Codierung") {
      return this.decBIT();
    } else if (el.value === "LZW Codierung") {
      return this.decLZW();
    } else {
      return this.decL();
    }
  };

  // Clone the Figure
  makeclone = function() {
    var col, el, str, tmpc;
    el = document.getElementById("selectCode");
    tmpc = this.code.split(",");
    if (el.value === "Bitmap Codierung" || el.value === "Lauflängen Codierung") {
      
      //len = @code.length
      col = tmpc[0];
      str = tmpc[1] + tmpc[1];
    } else if (el.value === "LZW Codierung") {
      col = tmpc.shift();
      //copy = tmpc[..]
      tmpc = tmpc.concat(tmpc);
      str = tmpc.join(",");
    } else {
      alert("not implemented");
    }
    this.code = col + "," + str;
    this.decode();
    this.buildFromCode();
    return false;
  };

  //Sub Column
  mincolumn = function() {
    var arr, l, m, ref, ref1, x, y;
    if (this.col > 2) {
      arr = [];
      arr.length = (this.col - 1) * this.row;
      for (y = l = 0, ref = this.row; 0 <= ref ? l < ref : l > ref; y = 0 <= ref ? ++l : --l) {
        for (x = m = 0, ref1 = this.col - 1; 0 <= ref1 ? m < ref1 : m > ref1; x = 0 <= ref1 ? ++m : --m) {
          arr[y * (this.col - 1) + x] = this.matrix[y * this.col + x];
        }
      }
      this.col = this.col - 1;
      this.matrix = arr;
      this.outCodeToForm();
      return this.buildFromCode();
    }
  };

  // Add Column
  addcolumn = function() {
    var arr, l, m, o, ref, ref1, ref2, tmp, x, y;
    if (this.col < this.maxcol) {
      arr = [];
      arr.length = (this.col + 1) * this.row;
      for (y = l = 0, ref = this.row - 1; 0 <= ref ? l < ref : l > ref; y = 0 <= ref ? ++l : --l) {
        for (x = m = 0, ref1 = this.col; 0 <= ref1 ? m < ref1 : m > ref1; x = 0 <= ref1 ? ++m : --m) {
          arr[y * (this.col + 1) + x] = this.matrix[y * this.col + x];
        }
        arr[y * (this.col + 1) + this.col] = this.farb;
      }
      // Danger last line could be partital filled
      // Fill up last line
      for (x = o = 0, ref2 = this.col; 0 <= ref2 ? o < ref2 : o > ref2; x = 0 <= ref2 ? ++o : --o) {
        tmp = this.matrix[(this.row - 1) * this.col + x];
        if (tmp === void 0) {
          tmp = this.farb;
        }
        arr[(this.row - 1) * (this.col + 1) + x] = tmp;
      }
      arr[(this.row - 1) * (this.col + 1) + this.col] = this.farb;
      this.col = this.col + 1;
      this.matrix = arr;
      this.outCodeToForm();
      return this.buildFromCode();
    }
  };

  // Ausertung des Formularfeldes
  evaluateInput = function(form) {
    var el, inp, input, zm;
    input = form.value;
    el = document.getElementById("selectCode");
    zm = [];
    inp = input.split(",");
    if (el.value === "Bitmap Codierung") {
      zm.push(parseInt(inp[0]));
      zm.push(inp[1]);
      this.code = zm.join(",");
    } else if (el.value === "LZW Codierung") {
      this.code = inp.join(",");
    } else if (el.value === "Lauflängen Codierung") {
      zm.push(parseInt(inp[0]));
      zm.push(inp[1]);
      this.code = zm.join(",");
    } else {
      alert("not Implemented");
    }
    this.decode();
    return this.buildFromCode();
  };

  bfromcode = function() {
    // @decode()
    clearAllChilds("code");
    this.element.innerHTML = grid.createGrid().join('');
    this.defgridborder();
    this.updateMat();
    this.outputParameters();
    this.registerEvents();
    return false;
  };

  outParamet = function() {
    wout("rowcol", `${this.col} x ${this.row} |         ${this.col} Spalten / ${this.row} Zeilen | ${this.bits} Bits`);
    return false;
  };

  outCode = function() {
    this.code = this.encode();
    return (document.getElementById("rle_code")).value = this.code;
  };

  // wout "rle_code",@code

  //Event Handler
  window.handleronChange = function(e) {
    var el, id, st;
    el = e.target;
    st = el.className;
    if (st === "smallBox cell") {
      id = parseInt(el.id);
      el = el.firstElementChild;
    } else {
      id = parseInt(el.parentElement.id);
    }
    grid.matrix[id] = grid.farb;
    el.className = `innerBox ${grid.farbTab[grid.farb]}`;
    e.stopPropagation();
    return false;
  };

  selectFarb = function(i) {
    var fel;
    fel = document.getElementById("f" + i);
    if (fel != null) {
      fel.className += " btn-primary";
    }
    return false;
  };

  deselectFarb = function(i) {
    var fel;
    fel = document.getElementById("f" + grid.farbNr[i]);
    if (fel != null) {
      fel.className = "btn btn-small";
    }
    return false;
  };

  handlerColorChage = function(e) {
    var el, nr, snr, st;
    el = e.target;
    if ((el.id.indexOf("f")) === 0) {
      st = el.id.split("f");
    } else {
      st = el.parentElement.id.split("f");
    }
    snr = st[st.length - 1];
    nr = parseInt(snr);
    if (nr >= 0) {
      deselectFarb(grid.farb);
      selectFarb(nr);
      return grid.farb = grid.farbCode[nr];
    }
  };

  grid = {
    row: 20,
    col: 22,
    maxcol: 22,
    size: 28,
    farb: "P",
    anzFarb: 8,
    bits: 0,
    matrix: [],
    code: "",
    createGrid: createCodeRows,
    defgridborder: defineStyle,
    createMat: createRandomMatrix,
    updateMat: updateMatrix,
    registerEvents: addinnerEvents,
    enLZW: encodeLZW,
    enBIT: encodeBIT,
    enL: encodeL,
    encode: enc,
    evalinp: evaluateInput,
    encode_lzw: enc_lzw,
    decode_lzw: dec_lzw,
    decLZW: decodeLZW,
    decBIT: decodeBIT,
    decL: decodeL,
    decode: dec,
    outCodeToForm: outCode,
    outputParameters: outParamet,
    addcol: addcolumn,
    mincol: mincolumn,
    clone: makeclone,
    buildFromCode: bfromcode
  };

  grid.farbTab = {
    "W": "weiss",
    "R": "rot",
    "P": "hellrosa",
    "N": "braun",
    "B": "blau",
    "Y": "gelb",
    "S": "schwarz",
    "G": "gruen"
  };

  grid.farbCode = {
    0: "W",
    1: "R",
    2: "P",
    3: "N",
    4: "B",
    5: "Y",
    6: "S",
    7: "G"
  };

  grid.farbNr = {
    "W": 0,
    "R": 1,
    "P": 2,
    "N": 3,
    "B": 4,
    "Y": 5,
    "S": 6,
    "G": 7
  };

  grid.element = document.getElementById("code");

  grid.element.innerHTML = grid.createGrid().join("");

  grid.defgridborder();

  selectFarb(grid.farb);

  //grid.element.addEventListener "mousedown",handleronChange,false
  //Random Start
  //grid.createMat()
  //grid.updateMat()
  //grid.encode()

  // Start with Mario
  grid.evalinp(document.getElementById("rle_code"));

  btf = document.getElementById("selectColor");

  btf.addEventListener("click", handlerColorChage, false);

  // Events an Formular binden 
  // Enter
  document.forms[0].onkeypress = function(e) {
    if (!e) {
      e = window.event;
    }
    if (e.keyCode === 13) {
      grid.evalinp(e.target);
      return false;
    }
  };

  // Click Decode
  bt = document.getElementById("btn_decode");

  bt.onclick = function(e) {
    grid.evalinp(document.getElementById("rle_code"));
    return false;
  };

  // Click Encode
  bt2 = document.getElementById("btn_encode");

  bt2.onclick = function(e) {
    grid.outCodeToForm();
    return false;
  };

  // Plus Spalte
  bt3 = document.getElementById("btn_addcol");

  bt3.onclick = function(e) {
    grid.addcol();
    return false;
  };

  // Plus Spalte
  bt4 = document.getElementById("btn_mincol");

  bt4.onclick = function(e) {
    grid.mincol();
    return false;
  };

  // Klonen
  bt4 = document.getElementById("btn_clone");

  bt4.onclick = function(e) {
    grid.clone();
    return false;
  };

  
  // Change Mode
  el = document.getElementById("selectCode");

  el.onchange = function(e) {
    var elLZWTable, elformat;
    elformat = document.getElementById("selectCodeFormat");
    elLZWTable = document.getElementById("LZW_Table");
    if (el.value === "Bitmap Codierung") {
      elformat.className = "span2 hide";
      elLZWTable.className = "hide";
    } else if (el.value === "LZW Codierung") {
      elformat.className = "span2";
      elLZWTable.className = "span5";
    } else {
      elformat.className = "span2 hide";
      elLZWTable.className = "hide";
    }
    grid.outCodeToForm();
    return false;
  };

  elformat = document.getElementById("selectCodeFormat");

  elformat.onchange = function(e) {
    grid.outCodeToForm();
    return false;
  };

}).call(this);
